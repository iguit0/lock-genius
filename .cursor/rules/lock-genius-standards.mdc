---
alwaysApply: false
---

# Lock Genius - Coding Standards & Architecture

## Project Context

Lock Genius is a modern password manager built with Next.js 14 App Router, TypeScript, and a comprehensive toolchain focused on type safety, security, and developer experience.

## Tech Stack Requirements

### Core Framework

- Use **Next.js 14** with App Router (not Pages Router)
- Write all code in **TypeScript** with strict mode
- Use **React 18** with Server/Client component patterns
- Default to Server Components, only use Client Components when necessary
- Use **pnpm** as package manager (as specified in README)

### Database & ORM

- Use **PostgreSQL** as the primary database
- Use **Prisma** as the ORM with proper migrations
- Follow NextAuth.js schema patterns for authentication
- Use `prisma generate` and `prisma db push` for database operations

### Authentication

- Use **NextAuth.js** for authentication
- Support GitHub OAuth provider
- Follow the established Account/Session/User/VerificationToken schema
- Use proper session management with `useSession` hook

### UI & Styling Standards

- Use **Tailwind CSS v4** utility classes for styling
- Implement **shadcn/ui** component patterns with **Radix UI** primitives
- Use **class-variance-authority (CVA)** for component variants
- Use **Lucide React** for icons
- Support dark mode with **next-themes**
- Use **tailwind-merge** for class merging via `cn` utility

### Form Handling Requirements

- Use **React Hook Form** for all form state management
- Use **Zod** for schema validation and TypeScript inference
- Always integrate with **@hookform/resolvers/zod**
- Implement proper error handling and accessibility
- Use `'use client'` directive for form components

### Environment & Configuration

- Use **T3 Env** (`@t3-oss/env-nextjs`) for environment validation
- Define schemas with Zod for type safety
- Keep sensitive data server-side only
- Use proper environment variable naming conventions

## Architecture Patterns

### File Organization

```
src/
├── app/                 # Next.js App Router
│   ├── api/            # API routes (v1 structure)
│   │   └── v1/         # Versioned API endpoints
│   ├── (routes)/       # App pages
│   └── layout.tsx      # Root layout
├── common/             # Shared utilities and constants
│   ├── api.ts          # Axios instance configuration
│   └── constants/      # Environment constants
├── components/         # React components
│   ├── ui/             # Base UI components (shadcn/ui)
│   ├── magicui/        # Magic UI components
│   └── [feature]/      # Feature-specific components
├── hooks/              # Custom React hooks
├── lib/                # Utility libraries
├── services/           # API service layer with types
├── styles/             # Global styles
├── types/              # TypeScript type definitions
└── __tests__/          # Test files
    └── unit/           # Unit tests
```

### Naming Conventions

- **Files**: kebab-case for components, camelCase for utilities
- **Components**: PascalCase with descriptive names
- **Functions**: camelCase
- **Constants**: SCREAMING_SNAKE_CASE
- **Types/Interfaces**: PascalCase with descriptive suffixes
- **API Routes**: Use versioned structure (`/api/v1/`)

## Component Standards

### React Component Pattern

Always use this pattern for reusable components:

```typescript
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const componentVariants = cva(
  'base-classes',
  {
    variants: {
      variant: {
        default: 'default-classes',
        secondary: 'secondary-classes',
      },
      size: {
        default: 'default-size',
        sm: 'small-size',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

export interface ComponentProps
  extends React.HTMLAttributes<HTMLElement>,
    VariantProps<typeof componentVariants> {
  asChild?: boolean;
}

const Component = React.forwardRef<HTMLElement, ComponentProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'div';
    return (
      <Comp
        className={cn(componentVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Component.displayName = 'Component';

export { Component, componentVariants };
```

### Form Component Pattern

Always use this pattern for forms:

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

import { Button } from '@/components/ui/button';
import { Form, FormControl, FormField, FormItem } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { cn } from '@/lib/utils';

const formSchema = z.object({
  field: z.string().min(1, 'Field is required'),
});

type FormSchema = z.infer<typeof formSchema>;

function MyForm() {
  const form = useForm<FormSchema>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      field: '',
    },
  });

  const onSubmit = async (values: FormSchema) => {
    try {
      // Handle submission
    } catch (error) {
      form.setError('root', { message: 'Error message' });
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        <FormField
          control={form.control}
          name="field"
          render={({ field }) => (
            <FormItem>
              <FormControl>
                <Input
                  className={cn(
                    form.formState.errors.field && 'border-destructive'
                  )}
                  {...field}
                />
              </FormControl>
            </FormItem>
          )}
        />
      </form>
    </Form>
  );
}
```

## API & Service Patterns

### API Route Pattern

```typescript
import { NextRequest, NextResponse } from 'next/server';

interface RequestBody {
  // Define request interface
}

export async function POST(request: NextRequest) {
  try {
    const body: RequestBody = await request.json();

    // Validate input
    if (!body.requiredField) {
      return NextResponse.json(
        { detail: 'Required field is missing' },
        { status: 400 }
      );
    }

    // Process request
    const result = await processRequest(body);

    return NextResponse.json(result, { status: 200 });
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Service Layer Pattern

```typescript
// password.types.ts
export interface GeneratePasswordRequestParams {
  params: {
    length: number;
    uppercase: boolean;
    lowercase: boolean;
    numbers: boolean;
    symbols: boolean;
  };
}

export interface GeneratePasswordResponse {
  password: string;
}

// password.service.ts
import {
  GeneratePasswordRequestParams,
  GeneratePasswordResponse,
} from './password.types';

import api from '@/common/api';

export const generatePassword = async ({
  params,
}: GeneratePasswordRequestParams): Promise<GeneratePasswordResponse> => {
  return await api.post('/passwords/generate', params).then((res) => res.data);
};
```

### API Configuration

```typescript
// common/api.ts
import axios, { AxiosInstance } from 'axios';

import { API_BASE_URL } from '@/common/constants/env';

const API_URL = API_BASE_URL || '/api/v1';

const api: AxiosInstance = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

export default api;
```

## Import Standards

### Import Order

1. React and Next.js imports
2. Third-party libraries
3. Internal components and utilities (using @/ aliases)
4. Type-only imports

```typescript
import React from 'react';
import { NextRequest, NextResponse } from 'next/server';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

import type { User } from '@/types/user';
```

## Styling Guidelines

### Tailwind Usage

- Use utility classes for styling
- Use the `cn` utility for conditional classes
- Follow mobile-first responsive design
- Use CSS variables for theming

```typescript
const className = cn('base-classes', {
  'conditional-class': condition,
  'error-class': hasError,
});
```

## Environment & Configuration

### Environment Variables

- Use T3 env for validation
- Define schemas with Zod
- Keep sensitive data server-side only

```typescript
// env.mjs
import { createEnv } from '@t3-oss/env-nextjs';
import { z } from 'zod';

export const env = createEnv({
  server: {
    DATABASE_URL: z.string().url(),
    NEXTAUTH_SECRET: z.string().min(1),
  },
  client: {
    NEXT_PUBLIC_SITE_URL: z.string().url(),
  },
  runtimeEnv: {
    DATABASE_URL: process.env.DATABASE_URL,
    NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,
    NEXT_PUBLIC_SITE_URL: process.env.NEXT_PUBLIC_SITE_URL,
  },
});
```

## Code Quality Requirements

### TypeScript

- Use strict TypeScript configuration
- Prefer type inference over explicit typing
- Use Zod for runtime type validation
- Define proper interfaces for all props and API responses

### Performance

- Use Server Components by default
- Implement proper caching strategies
- Use dynamic imports for code splitting
- Avoid unnecessary client-side JavaScript

### Accessibility

- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Use Radix UI primitives for accessibility

### Security

- Validate all user inputs with Zod
- Use proper authentication patterns with NextAuth.js
- Implement CSRF protection
- Use cryptographically secure random generation for passwords
- Keep sensitive data secure

## Testing Standards

### Jest Configuration

- Use Jest with Testing Library
- Test user interactions and accessibility
- Mock external dependencies (NextAuth, API calls)
- Use descriptive test names
- Follow the established test structure in `src/__tests__/unit/`

```typescript
// Example test pattern
import { render } from '@testing-library/react';
import { useSession } from 'next-auth/react';

import Component from '@/components/component';

const mockUseSession = useSession as jest.Mock;

jest.mock('next-auth/react');

describe('Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render correctly', () => {
    mockUseSession.mockReturnValue({
      status: 'authenticated',
      data: { user: { name: 'Test User' } },
    });

    const { getByText } = render(<Component />);
    expect(getByText('Test User')).toBeInTheDocument();
  });
});
```

## Development Workflow

### Scripts

- `pnpm dev`: Start development server with Prisma generation
- `pnpm build`: Build with Prisma generation and database push
- `pnpm test`: Run Jest tests
- `pnpm test:coverage`: Run tests with coverage
- `pnpm lint`: Run ESLint
- `pnpm format:write`: Format code with Prettier
- `pnpm typecheck`: TypeScript type checking

### Database Management

- `pnpm db:setup`: Setup database with Prisma
- `pnpm db:reset`: Reset database
- `pnpm db:studio`: Open Prisma Studio

### Docker Support

- `pnpm docker:up`: Start Docker services
- `pnpm docker:down`: Stop Docker services
- `pnpm docker:logs`: View Docker logs

## Security Best Practices

### Password Generation

- Use cryptographically secure random generation
- Implement proper character set validation
- Ensure at least one character set is selected
- Use Web Crypto API for secure random numbers

### Authentication

- Use NextAuth.js for secure authentication
- Implement proper session management
- Use environment variables for secrets
- Follow OAuth 2.0 best practices

Follow these standards consistently throughout the codebase to maintain code quality, security, and developer experience.
description:
globs:
alwaysApply: true

---
